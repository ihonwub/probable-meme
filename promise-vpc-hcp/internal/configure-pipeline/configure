#!/usr/bin/env sh

set -euo pipefail

echo "Starting pipeline configuration...***"

if [ "${KRATIX_WORKFLOW_TYPE}" = "promise" ]; then
  cat <<EOF > /kratix/output/main.tf
terraform {
}

provider "aws" {
  region = "us-east-1"
}
EOF
  exit 0
fi

# Read user input
providedName="$(yq eval '.metadata.name' /kratix/input/object.yaml)"
enableNatGateway="$(yq eval '.spec.enable_nat_gateway' /kratix/input/object.yaml)"
cidr="$(yq eval '.spec.cidr' /kratix/input/object.yaml)"
create_igw="$(yq eval '.spec.create_igw // false' /kratix/input/object.yaml)"
tags_json=$(yq eval -o=json '.spec.tags // {}' /kratix/input/object.yaml)

# Check if this is a re-run (e.g. after an update)
vpcName=$(yq eval '.status.vpcName // ""' /kratix/input/object.yaml)
if [ -z "${vpcName}" ]; then
  echo "No previous VPC name found, so this is a new resource..."
  vpcName="${ORG_NAME}-org-${providedName}-$RANDOM"
fi

# Create Terraform configuration
cat <<EOF > /kratix/output/${vpcName}.tf
module "${vpcName}_vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "6.0.1"

  name                = "${vpcName}"
  cidr                = "${cidr}"
  enable_nat_gateway  = ${enableNatGateway}
  create_igw         = ${create_igw}
  tags                = jsondecode("${tags_json}")
}

output "${vpcName}-vpc_id" {
  value = module.${vpcName}_vpc.vpc_id
}

output "${vpcName}-vpc_name" {
  value = module.${vpcName}_vpc.name
}
EOF

# Update resource status
cat <<EOF > /kratix/metadata/status.yaml
ready: "False"
vpcName: ${vpcName}
EOF


# Debug
echo "Generated Terraform configuration:"
cat /kratix/output/${vpcName}.tf

echo "****************"

echo "Resource Status Pre Update Status:"
cat /kratix/metadata/status.yaml

echo "*******END*********"


# name=$(yq '.metadata.name' /kratix/input/object.yaml)
# enable_nat_gateway=$(yq '.spec.enable_nat_gateway' /kratix/input/object.yaml)
# cidr=$(yq '.spec.cidr' /kratix/input/object.yaml)


# cd resources
# terraform init

# # Check if the state exists and retrieve it if so
# if kubectl get configmap ${name}-state; then
#     kubectl get configmap ${name}-state \
#         --output=jsonpath='{.data.tfstate}' \
#         > state.tfstate
# fi

# terraform apply \
#   -auto-approve \
#   -var="enable_nat_gateway=${enable_nat_gateway}" \
#     -var="name=${name}" \
#     -var="cidr=${cidr}" \
#     -state=state.tfstate

# # Store the state in a ConfigMap
# kubectl create configmap ${name}-state \
#     --from-file=tfstate=state.tfstate \
#     --dry-run=client \
#     --output=yaml > configmap.yaml
# kubectl replace --filename configmap.yaml --force


