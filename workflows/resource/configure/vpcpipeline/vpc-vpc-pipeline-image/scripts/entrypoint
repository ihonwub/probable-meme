#!/usr/bin/env sh

set -euxo pipefail

name=$(yq '.metadata.name' /kratix/input/object.yaml)
enable_nat_gateway=$(yq '.spec.enable_nat_gateway' /kratix/input/object.yaml)
cidr=$(yq '.spec.cidr' /kratix/input/object.yaml)

echo $MODULE_SOURCE
echo $MODULE_VERSION


source="${MODULE_SOURCE:?MODULE_SOURCE not set}"
version="${MODULE_VERSION:?MODULE_VERSION not set}"

echo "✅ Rendering main.tf:"

cat <<EOF > /kratix/output/main.tf
module "vpc" {
  source  = "${source}?ref=${version}"

  name                = "${name}"
  cidr                = "${cidr}"
  enable_nat_gateway  = ${enable_nat_gateway}
}
EOF

echo "✅ Rendered main.tf:"
cat /kratix/output/main.tf

# name=$(yq '.metadata.name' /kratix/input/object.yaml)
# enable_nat_gateway=$(yq '.spec.enable_nat_gateway' /kratix/input/object.yaml)
# cidr=$(yq '.spec.cidr' /kratix/input/object.yaml)


# cd resources
# terraform init

# # Check if the state exists and retrieve it if so
# if kubectl get configmap ${name}-state; then
#     kubectl get configmap ${name}-state \
#         --output=jsonpath='{.data.tfstate}' \
#         > state.tfstate
# fi

# terraform apply \
#   -auto-approve \
#   -var="enable_nat_gateway=${enable_nat_gateway}" \
#     -var="name=${name}" \
#     -var="cidr=${cidr}" \
#     -state=state.tfstate

# # Store the state in a ConfigMap
# kubectl create configmap ${name}-state \
#     --from-file=tfstate=state.tfstate \
#     --dry-run=client \
#     --output=yaml > configmap.yaml
# kubectl replace --filename configmap.yaml --force


